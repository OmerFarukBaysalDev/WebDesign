<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donanım Mimarisi - İleri Seviye Final</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1e1e2e;
            --card-bg: #2d2d44;
            --text-main: #e0e0e0;
            --text-muted: #a0a0b0;
            --accent: #bb86fc;
            --correct: #00e676;
            --wrong: #ff5252;
            --option-bg: #373756;
            --option-hover: #45456b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .quiz-container {
            background-color: var(--card-bg);
            width: 100%;
            max-width: 950px;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.05);
        }

        /* Header Area */
        .header {
            padding: 25px 30px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .title-group h1 { font-size: 1.3rem; color: var(--accent); font-weight: 700; letter-spacing: 0.5px; }
        .title-group p { font-size: 0.85rem; color: var(--text-muted); margin-top: 5px; }

        .stats { display: flex; gap: 15px; }
        .stat-item {
            background: rgba(255,255,255,0.05);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .text-correct { color: var(--correct); }
        .text-wrong { color: var(--wrong); }

        /* Progress Bar */
        .progress-container { width: 100%; height: 6px; background: #1a1a2e; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, var(--accent), #7c4dff); width: 0%; transition: width 0.4s ease; }

        /* Content */
        .content { padding: 40px 30px; }

        .question-badge {
            display: inline-block;
            background: rgba(187, 134, 252, 0.15);
            color: var(--accent);
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .question-text {
            font-size: 1.3rem;
            font-weight: 600;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        /* Options */
        .options-list { display: flex; flex-direction: column; gap: 12px; }
        
        .option-btn {
            background: var(--option-bg);
            color: var(--text-main);
            border: 2px solid transparent;
            padding: 18px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1rem;
            position: relative;
        }

        .option-btn:hover:not(.disabled) { background: var(--option-hover); transform: translateX(5px); }
        .option-btn.disabled { cursor: default; opacity: 0.7; transform: none; }

        .btn-letter {
            width: 32px; height: 32px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 0.9rem; color: var(--accent);
            flex-shrink: 0;
        }

        /* Answer States */
        .option-btn.correct { background: rgba(0, 230, 118, 0.15); border-color: var(--correct); color: var(--correct); }
        .option-btn.correct .btn-letter { background: var(--correct); color: #000; }

        .option-btn.wrong { background: rgba(255, 82, 82, 0.15); border-color: var(--wrong); color: var(--wrong); }
        .option-btn.wrong .btn-letter { background: var(--wrong); color: white; }

        /* Explanation Section */
        .explanation-container {
            margin-top: 25px;
            display: none; /* Default Hidden */
        }
        
        .toggle-exp-btn {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .toggle-exp-btn:hover { background: rgba(187, 134, 252, 0.1); }

        .explanation-box {
            margin-top: 15px;
            background: rgba(255,255,255,0.05);
            border-left: 4px solid var(--accent);
            padding: 20px;
            border-radius: 0 8px 8px 0;
            line-height: 1.6;
            font-size: 0.95rem;
            color: #d1d1e0;
            display: none; /* Initially hidden inside container */
            animation: fadeIn 0.4s ease;
        }

        /* Footer */
        .footer {
            padding: 20px 30px;
            border-top: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
        }

        .nav-btn {
            background: var(--option-bg);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: 0.3s;
            display: flex; align-items: center; gap: 8px;
        }
        
        .nav-btn:hover:not(:disabled) { background: var(--accent); color: #000; }
        .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Result Screen */
        #result-screen { display: none; text-align: center; padding: 60px 20px; }
        .final-score { font-size: 4rem; font-weight: 800; color: var(--accent); margin-bottom: 10px; }
        .result-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            max-width: 400px; margin: 30px auto;
        }
        .res-card { padding: 20px; border-radius: 15px; background: rgba(255,255,255,0.05); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        @media (max-width: 600px) {
            .header { flex-direction: column; align-items: flex-start; gap: 15px; }
            .option-btn { font-size: 0.9rem; padding: 15px; }
        }
    </style>
</head>
<body>

<div class="quiz-container">
    <div id="quiz-screen">
        <div class="progress-container"><div class="progress-bar" id="progress"></div></div>
        
        <div class="header">
            <div class="title-group">
                <h1>BİLGİSAYAR MİMARİSİ FİNAL</h1>
                <p>Zorluk: İleri | 5 Şıklı Sistem</p>
            </div>
            <div class="stats">
                <div class="stat-item"><i class="fas fa-bars"></i> <span id="q-counter">1/70</span></div>
                <div class="stat-item text-correct"><i class="fas fa-check"></i> <span id="s-correct">0</span></div>
                <div class="stat-item text-wrong"><i class="fas fa-times"></i> <span id="s-wrong">0</span></div>
            </div>
        </div>

        <div class="content">
            <span class="question-badge" id="q-topic">Konu</span>
            <div class="question-text" id="q-text">Soru yükleniyor...</div>

            <div class="options-list" id="opt-list">
                </div>

            <div class="explanation-container" id="exp-container">
                <button class="toggle-exp-btn" onclick="toggleExplanation()">
                    <i class="fas fa-lightbulb"></i> Açıklamayı Göster / Gizle
                </button>
                <div class="explanation-box" id="exp-box">
                    </div>
            </div>
        </div>

        <div class="footer">
            <button class="nav-btn" id="prev-btn" onclick="prevQuestion()" disabled>
                <i class="fas fa-arrow-left"></i> Geri
            </button>
            <button class="nav-btn" id="next-btn" onclick="nextQuestion()" disabled>
                Sonraki <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>

    <div id="result-screen">
        <h2 style="font-size: 2rem; margin-bottom: 10px;">Test Tamamlandı</h2>
        <p style="color: var(--text-muted);">Performans Sonucunuz</p>

        <div class="final-score" id="final-percent">%0</div>
        
        <div class="result-grid">
            <div class="res-card" style="border-bottom: 4px solid var(--correct);">
                <div style="font-size: 2rem; color: var(--correct); font-weight: bold;" id="final-true">0</div>
                <div style="font-size: 0.9rem;">DOĞRU</div>
            </div>
            <div class="res-card" style="border-bottom: 4px solid var(--wrong);">
                <div style="font-size: 2rem; color: var(--wrong); font-weight: bold;" id="final-false">0</div>
                <div style="font-size: 0.9rem;">YANLIŞ</div>
            </div>
        </div>

        <button class="nav-btn" onclick="location.reload()" style="margin: 0 auto; background: var(--accent); color: #000;">
            <i class="fas fa-redo"></i> Testi Tekrarla
        </button>
    </div>
</div>

<script>
    // 5 ŞIKLI, ZORLAYICI VE ÇELDİRİCİ SORULAR
    const questions = [
        // --- 1. TARİHÇE VE TEMELLER (10 Soru) ---
        {
            t: "Bilgisayar Tarihçesi",
            q: "ENIAC ile ilgili aşağıdaki teknik detaylardan hangisi kesinlikle yanlıştır?",
            o: ["Askeri topçu atış cetvellerini hesaplamak için tasarlanmıştır.", "Programlanması, kablo ve anahtarların elle değiştirilmesiyle yapılıyordu.", "İkili (Binary) sayı sistemi yerine Onluk (Decimal) sistem kullanıyordu.", "Belleğinde program saklayabilen (Stored Program) ilk bilgisayardır.", "Yaklaşık 18.000 vakum tüpünden oluşuyordu."],
            a: "Belleğinde program saklayabilen (Stored Program) ilk bilgisayardır.",
            exp: "ENIAC programlanabilirdi ancak program hafızada saklanmıyordu. Stored Program konsepti Von Neumann mimarisi (EDVAC/IAS) ile gelmiştir."
        },
        {
            t: "Moore Yasası",
            q: "Gordon Moore'un 1965'te ortaya attığı Moore Yasası'nın en doğru teknik tanımı hangisidir?",
            o: ["Bilgisayar hızları her 18 ayda bir ikiye katlanır.", "Entegre devrelerdeki transistör sayısı yaklaşık her 2 yılda bir iki katına çıkar.", "İşlemci fiyatları her yıl yarı yarıya düşer.", "Transistörlerin güç tüketimi her 2 yılda bir yarıya iner.", "Veri depolama kapasitesi her yıl katlanarak artar."],
            a: "Entegre devrelerdeki transistör sayısı yaklaşık her 2 yılda bir iki katına çıkar.",
            exp: "Moore yasası doğrudan 'hız' değil, birim alandaki 'transistör yoğunluğu' ile ilgilidir."
        },
        {
            t: "Von Neumann Mimarisi",
            q: "Von Neumann mimarisinin (IAS) modern bilgisayarların temelini oluşturan en kritik özelliği nedir?",
            o: ["Çok çekirdekli işlemci yapısına izin vermesi.", "Verilerin ve komutların (programın) aynı okunabilir/yazılabilir bellekte saklanması.", "Sadece ikili sayı sistemini desteklemesi.", "Giriş ve çıkış birimlerinin işlemciden bağımsız çalışması.", "Transistör teknolojisine geçişi sağlaması."],
            a: "Verilerin ve komutların (programın) aynı okunabilir/yazılabilir bellekte saklanması.",
            exp: "Von Neumann mimarisinin devrimi, programın da veri gibi bellekte tutulmasıdır (Stored Program Concept)."
        },
        {
            t: "Mikroişlemciler",
            q: "Intel 4004 işlemcisinin tarihteki önemi nedir?",
            o: ["İlk kişisel bilgisayar olan Altair 8800'ün işlemcisidir.", "Dünyanın ilk ticari mikroişlemcisi olup tüm CPU fonksiyonlarını tek çipte toplamıştır.", "1 GHz hız barajını aşan ilk işlemcidir.", "Grafik arayüzü destekleyen ilk işlemcidir.", "Transistör yerine entegre devre kullanan ilk işlemcidir."],
            a: "Dünyanın ilk ticari mikroişlemcisi olup tüm CPU fonksiyonlarını tek çipte toplamıştır.",
            exp: "1971'de çıkan Intel 4004, dağınık devre elemanlarını tek bir silikon yongaya sığdırarak mikroişlemci devrini başlatmıştır."
        },
        {
            t: "Bilgisayar Tarihçesi",
            q: "İlk kişisel bilgisayar (PC) olarak kabul edilen ve 1975'te piyasaya sürülen cihaz hangisidir?",
            o: ["Apple I", "IBM PC 5150", "Altair 8800", "Commodore 64", "UNIVAC I"],
            a: "Altair 8800",
            exp: "Altair 8800, kit halinde satılan ve mikrobilgisayar devrimini başlatan ilk popüler kişisel bilgisayardır."
        },
        {
            t: "Transistör Teknolojisi",
            q: "Vakum tüplerinden transistörlere geçişin bilişim sistemlerine sağladığı en büyük fiziksel avantaj nedir?",
            o: ["Daha yüksek voltaj ile çalışabilme.", "Yazılım hatalarını donanımsal olarak düzeltme.", "Isı üretimini ve enerji tüketimini azaltarak minyatürleşmeyi (küçülmeyi) sağlama.", "Analog sinyalleri tamamen ortadan kaldırma.", "Veri güvenliğini şifreleme ile sağlama."],
            a: "Isı üretimini ve enerji tüketimini azaltarak minyatürleşmeyi (küçülmeyi) sağlama.",
            exp: "Transistörler, çok ısınan ve büyük yer kaplayan tüplerin yerini alarak cihazların masaüstü boyutuna inmesini sağlamıştır."
        },
        {
            t: "Ticari Bilgisayarlar",
            q: "Askeri amaçlar dışında üretilen ve satılan ilk ticari bilgisayar hangisidir?",
            o: ["ENIAC", "EDVAC", "UNIVAC I", "IBM 360", "Colossus"],
            a: "UNIVAC I",
            exp: "UNIVAC I, nüfus sayımı gibi sivil ve ticari işler için üretilen ve satılan ilk genel amaçlı bilgisayardır."
        },
        {
            t: "Bilgi Birimleri",
            q: "Aşağıdaki veri büyüklüğü sıralamalarından hangisi doğrudur?",
            o: ["KB < MB < GB < PB < TB", "MB < GB < TB < ZB < PB", "KB < MB < GB < TB < PB", "GB < MB < KB < TB < PB", "MB < KB < GB < PB < TB"],
            a: "KB < MB < GB < TB < PB",
            exp: "Sıralama: Kilo, Mega, Giga, Tera, Peta şeklindedir."
        },
        {
            t: "Bilişim Etkileri",
            q: "Bilişim sistemlerinin toplumsal etkileri düşünüldüğünde, 'Dijital Uçurum' (Digital Divide) kavramı neyi ifade eder?",
            o: ["İşlemciler arasındaki hız farkını.", "Teknolojiye erişimi olanlar ile olmayanlar arasındaki eşitsizliği.", "Analog ve dijital veriler arasındaki uyumsuzluğu.", "İnternet hızının bölgelere göre değişmesini.", "Yazılım ve donanım mühendisleri arasındaki maaş farkını."],
            a: "Teknolojiye erişimi olanlar ile olmayanlar arasındaki eşitsizliği.",
            exp: "Dijital uçurum, sosyo-ekonomik nedenlerle teknolojiye ve bilgiye erişimdeki adaletsizliği tanımlar."
        },
        {
            t: "Sistem Mimarisi",
            q: "IAS (Von Neumann) makinesinde 'Program Sayacı'nın (Program Counter - PC) görevi nedir?",
            o: ["Çalıştırılan komutun sonucunu saklamak.", "Bir sonraki çalıştırılacak komutun bellek adresini tutmak.", "Programın kaç saniyedir çalıştığını saymak.", "Döngü sayısını hesaplamak.", "RAM'deki boş alan miktarını saymak."],
            a: "Bir sonraki çalıştırılacak komutun bellek adresini tutmak.",
            exp: "PC (Program Counter), işlemcinin sırada hangi komutu işleyeceğini bilmesini sağlayan özel bir yazmaçtır."
        },

        // --- 2. İŞLEMCİ (CPU) MİMARİSİ (15 Soru) ---
        {
            t: "CPU Bileşenleri",
            q: "CPU içerisindeki Kontrol Birimi'nin (Control Unit) temel görevi nedir?",
            o: ["Aritmetik işlemleri yapmak.", "Verileri kalıcı olarak depolamak.", "Bellekten gelen komutları çözmek (Decode) ve birimler arası veri akışını yönetmek.", "Önbellek (Cache) yönetimini sağlamak.", "Grafik işlemlerini hızlandırmak."],
            a: "Bellekten gelen komutları çözmek (Decode) ve birimler arası veri akışını yönetmek.",
            exp: "Kontrol birimi işlem yapmaz, işlemi yönetir. Komutları yorumlar ve ALU gibi birimlere ne yapacağını söyler."
        },
        {
            t: "CPU Bileşenleri",
            q: "ALU (Aritmetik Mantık Birimi) aşağıdakilerden hangisini GERÇEKLEŞTİRMEZ?",
            o: ["Toplama işlemi", "Çıkarma işlemi", "AND, OR kapı işlemleri", "Komutun bellekten getirilmesi (Fetch)", "Sayısal karşılaştırma (Büyüktür/Küçüktür)"],
            a: "Komutun bellekten getirilmesi (Fetch)",
            exp: "Fetch (Getirme) işlemi Kontrol Birimi'nin yönetiminde yapılır. ALU sadece hesaplama ve mantık kısmını icra eder."
        },
        {
            t: "Önbellek (Cache)",
            q: "İşlemci neden RAM yerine öncelikle Cache (Önbellek) belleğe bakar?",
            o: ["Cache bellek daha ucuz olduğu için.", "Cache bellek işlemcinin içinde veya çok yakınında olup RAM'den çok daha hızlı olduğu için.", "RAM'deki veriler güvenilir olmadığı için.", "İşletim sistemi Cache üzerinde çalıştığı için.", "Cache bellek daha yüksek kapasiteli olduğu için."],
            a: "Cache bellek işlemcinin içinde veya çok yakınında olup RAM'den çok daha hızlı olduğu için.",
            exp: "Cache, işlemci ile yavaş RAM arasındaki hız farkını kapatmak için kullanılan çok hızlı ancak kapasitesi düşük bellektir."
        },
        {
            t: "Cache Hiyerarşisi",
            q: "L1, L2 ve L3 Cache sıralaması ile ilgili hangisi doğrudur?",
            o: ["L1 en yavaş ama en büyük kapasitelidir.", "L3 en hızlı ve en küçük kapasitelidir.", "L1 en hızlı ve en küçük, L3 ise L1'e göre daha yavaş ama daha büyüktür.", "Hızları eşittir, sadece konumları farklıdır.", "L2 sadece grafik işlemleri için kullanılır."],
            a: "L1 en hızlı ve en küçük, L3 ise L1'e göre daha yavaş ama daha büyüktür.",
            exp: "İşlemci çekirdeğine en yakın olan L1 en hızlısıdır. L3 ise çekirdekler arasında paylaşılır ve daha büyüktür."
        },
        {
            t: "RISC vs CISC",
            q: "Mobil cihazlarda yaygın olan ARM mimarisinin (RISC) temel felsefesi nedir?",
            o: ["Karmaşık komutları tek seferde işlemek.", "Basit ve az sayıda komut seti kullanarak enerji verimliliği ve hız sağlamak.", "Donanım karmaşıklığını artırıp yazılımı basitleştirmek.", "Sadece tek çekirdekli çalışmak.", "Yüksek güç tüketimi ile maksimum performans almak."],
            a: "Basit ve az sayıda komut seti kullanarak enerji verimliliği ve hız sağlamak.",
            exp: "RISC (Reduced Instruction Set), basit komutlarla hızlı ve az enerji tüketen işlemleri hedefler."
        },
        {
            t: "RISC vs CISC",
            q: "Intel ve AMD işlemcilerde kullanılan x86 mimarisi genellikle hangi sınıfa girer?",
            o: ["RISC (Reduced Instruction Set)", "CISC (Complex Instruction Set)", "MISC (Minimal Instruction Set)", "VLIW", "ARM"],
            a: "CISC (Complex Instruction Set)",
            exp: "Masaüstü ve sunucularda kullanılan x86 mimarisi, tek komutla karmaşık işler yapabilen CISC tabanlıdır."
        },
        {
            t: "İşlemci Performansı",
            q: "Saat Hızı (Clock Speed - GHz) işlemci performansı için tek başına neden yeterli bir ölçüt değildir?",
            o: ["Çünkü GHz sadece sıcaklığı gösterir.", "Çünkü performans; döngü başına yapılan işlem (IPC), çekirdek sayısı ve mimariye de bağlıdır.", "Çünkü tüm işlemciler aynı GHz hızında çalışır.", "Çünkü GHz sadece RAM hızını etkiler.", "Çünkü yazılımlar hıza bakmaz."],
            a: "Çünkü performans; döngü başına yapılan işlem (IPC), çekirdek sayısı ve mimariye de bağlıdır.",
            exp: "Eski bir 3.0 GHz işlemci, yeni nesil 2.0 GHz işlemciden çok daha yavaş olabilir. Mimari verimlilik (IPC) önemlidir."
        },
        {
            t: "Makine Döngüsü",
            q: "Fetch - Decode - Execute - Store döngüsünde 'Decode' aşaması ne anlama gelir?",
            o: ["Verinin RAM'den alınması.", "İşlemin sonucunun yazılması.", "Alınan komutun ne olduğunun anlaşılması ve gerekli sinyallerin üretilmesi.", "İşlemin matematiksel olarak yapılması.", "Bilgisayarın açılması."],
            a: "Alınan komutun ne olduğunun anlaşılması ve gerekli sinyallerin üretilmesi.",
            exp: "Decode (Çözme), getirilen 1 ve 0 yığınlarının hangi emir olduğunu (topla, çıkar, taşı vb.) anlama aşamasıdır."
        },
        {
            t: "Teknolojiler",
            q: "Hyper-Threading (Intel) veya SMT (AMD) teknolojisinin amacı nedir?",
            o: ["İşlemciyi soğutmak.", "Bir fiziksel çekirdeği işletim sistemine iki mantıksal çekirdek gibi gösterip kaynak kullanımını artırmak.", "RAM kapasitesini ikiye katlamak.", "Ekran kartı performansını artırmak.", "İnternet hızını artırmak."],
            a: "Bir fiziksel çekirdeği işletim sistemine iki mantıksal çekirdek gibi gösterip kaynak kullanımını artırmak.",
            exp: "Bu teknoloji sayesinde işlemci, boşta kalan birimlerini kullanarak aynı anda iki iş parçacığını (thread) işleyebilir."
        },
        {
            t: "İşlemci Kayıtçıları",
            q: "Register (Yazmaç) belleklerin en belirgin özelliği nedir?",
            o: ["Çok büyük kapasiteli olmaları.", "Kalıcı (Non-volatile) olmaları.", "CPU'nun içinde bulunmaları ve sistemdeki en hızlı bellek birimi olmaları.", "Harici olarak takılıp çıkarılabilmeleri.", "Grafik verilerini saklamaları."],
            a: "CPU'nun içinde bulunmaları ve sistemdeki en hızlı bellek birimi olmaları.",
            exp: "Registerlar işlemcinin 'çalışma masasıdır'. Kapasiteleri bitlerle ifade edilir ama hızları işlemci hızıyla aynıdır."
        },
        {
            t: "Geleceğin İşlemcileri",
            q: "Kuantum bilgisayarların klasik işlemcilerden temel farkı nedir?",
            o: ["Daha fazla elektrik tüketmeleri.", "Bit yerine Qubit (Kuantum Bit) kullanarak 0 ve 1 durumunda aynı anda bulunabilmeleri.", "Silikon yerine karbon kullanmaları.", "Windows çalıştıramamaları.", "Daha yavaş ama daha güvenli olmaları."],
            a: "Bit yerine Qubit (Kuantum Bit) kullanarak 0 ve 1 durumunda aynı anda bulunabilmeleri.",
            exp: "Süperpozisyon ilkesi sayesinde kuantum bilgisayarlar, klasik bilgisayarların milyonlarca yılda çözeceği sorunları saniyeler içinde çözebilir."
        },
        {
            t: "Soğutma",
            q: "İşlemci ile soğutucu blok arasına sürülen termal macunun görevi nedir?",
            o: ["İşlemciyi yapıştırmak.", "Hava boşluklarını doldurarak ısı iletimini en üst düzeye çıkarmak.", "Elektrik yalıtımı sağlamak.", "Fan hızını kontrol etmek.", "Görsel güzellik katmak."],
            a: "Hava boşluklarını doldurarak ısı iletimini en üst düzeye çıkarmak.",
            exp: "Hava ısıyı iyi iletmez. Macun, mikroskobik boşlukları doldurarak ısıyı metal bloğa aktarır."
        },
        {
            t: "Boru Hattı",
            q: "Pipelining (Boru Hattı) tekniği işlemci performansını nasıl artırır?",
            o: ["İşlemci hızını (GHz) artırarak.", "Birden fazla komutun farklı aşamalarını (Fetch, Decode, Execute) aynı anda işleyerek.", "Çekirdek sayısını artırarak.", "Önbelleği büyüterek.", "RAM voltajını düşürerek."],
            a: "Birden fazla komutun farklı aşamalarını (Fetch, Decode, Execute) aynı anda işleyerek.",
            exp: "Fabrika bandı gibi; bir komut işlenirken diğeri getirilir, öbürü çözülür. Böylece her saat döngüsünde bir iş biter."
        },
        {
            t: "Kelime Uzunluğu",
            q: "Bir işlemcinin 32-bit veya 64-bit olması teknik olarak neyi ifade eder?",
            o: ["İşlemcinin fiziksel boyutunu.", "Tek seferde işleyebildiği veri miktarını ve adresleyebildiği RAM kapasitesini.", "İnternet hızını.", "Desteklediği USB sayısını.", "Üretim yılını."],
            a: "Tek seferde işleyebildiği veri miktarını ve adresleyebildiği RAM kapasitesini.",
            exp: "64-bit işlemciler, 32-bit'e göre çok daha büyük sayıları işleyebilir ve 4GB'dan fazla RAM adresleyebilir."
        },
        {
            t: "Çok Çekirdek",
            q: "Multi-core (Çok çekirdekli) işlemcilerin geliştirilme sebebi nedir?",
            o: ["Tek çekirdekte frekans (hız) artışının aşırı ısınma ve fiziksel sınırlara takılması.", "Yazılımların daha ucuz olması.", "Transistörlerin bitmesi.", "RAM fiyatlarının düşmesi.", "Ekran kartlarının yetersiz kalması."],
            a: "Tek çekirdekte frekans (hız) artışının aşırı ısınma ve fiziksel sınırlara takılması.",
            exp: "Hızı sonsuza kadar artıramadığımız için (ısı duvarı), işlem gücünü paralel çalışan birden fazla çekirdeğe bölmeye başladık."
        },

        // --- 3. ANAKART VE SİSTEM (10 Soru) ---
        {
            t: "Anakart",
            q: "Anakart üzerindeki 'Chipset' (Yonga Seti) bileşeninin temel görevi nedir?",
            o: ["Elektrik üretmek.", "İşlemci, RAM, Ekran kartı ve diğer çevre birimleri arasındaki veri trafiğini koordine etmek.", "Bilgisayarı virüslerden korumak.", "Ses çıkışı sağlamak.", "İnternet bağlantısını sağlamak."],
            a: "İşlemci, RAM, Ekran kartı ve diğer çevre birimleri arasındaki veri trafiğini koordine etmek.",
            exp: "Chipset, anakartın trafik polisidir. Hangi verinin nereye gideceğini yönetir."
        },
        {
            t: "Kuzey Köprüsü",
            q: "Eski mimarilerde Kuzey Köprüsü (Northbridge) hangi bileşenleri yönetirdi?",
            o: ["USB, Klavye, Mouse", "Sabit Disk, Ses Kartı", "CPU, RAM, Ekran Kartı (AGP/PCIe)", "BIOS, Pil", "Ethernet, Yazıcı"],
            a: "CPU, RAM, Ekran Kartı (AGP/PCIe)",
            exp: "Kuzey köprüsü, yüksek hız gerektiren (CPU-RAM-GPU) hattı yönetirdi. Günümüzde bu işlev işlemcinin içine taşınmıştır."
        },
        {
            t: "BIOS",
            q: "BIOS'un (Basic Input/Output System) bilgisayar açılışındaki ilk görevi nedir?",
            o: ["Windows'u yüklemek.", "POST (Power On Self Test) ile donanımları test etmek.", "İnternete bağlanmak.", "Ekran çözünürlüğünü ayarlamak.", "Kullanıcı şifresini sormak."],
            a: "POST (Power On Self Test) ile donanımları test etmek.",
            exp: "Bilgisayar açma tuşuna basıldığında BIOS devreye girer, donanımları kontrol eder (POST) ve sonra işletim sistemini arar."
        },
        {
            t: "CMOS",
            q: "Bilgisayarın fişi çekilse bile saat ve tarih ayarlarının sıfırlanmamasının sebebi nedir?",
            o: ["Sabit diskin manyetik özelliği.", "BIOS yazılımının gücü.", "Anakart üzerindeki pil ile beslenen CMOS belleği.", "RAM üzerindeki statik elektrik.", "İşlemcinin yedek enerjisi."],
            a: "Anakart üzerindeki pil ile beslenen CMOS belleği.",
            exp: "CMOS, çok az enerji tüketen bir RAM türüdür ve pil sayesinde ayarları (tarih, saat, boot sırası) hafızasında tutar."
        },
        {
            t: "Veri Yolları",
            q: "FSB (Front Side Bus) kavramı neyi ifade eder?",
            o: ["USB girişlerinin hızını.", "İşlemci ile Kuzey Köprüsü (veya RAM) arasındaki veri yolunu.", "Ekran kartının bellek hızını.", "Sabit diskin dönme hızını.", "Güç kaynağının kapasitesini."],
            a: "İşlemci ile Kuzey Köprüsü (veya RAM) arasındaki veri yolunu.",
            exp: "Eski sistemlerde işlemcinin dış dünyayla konuştuğu ana yoldu. Darboğaz oluşturduğu için modern sistemlerde yerini QPI veya HyperTransport'a bıraktı."
        },
        {
            t: "Form Faktör",
            q: "ATX, Micro-ATX ve Mini-ITX terimleri anakartın hangi özelliğini belirtir?",
            o: ["İşlemci desteğini", "RAM kapasitesini", "Fiziksel boyutlarını ve vida montaj standartlarını (Form Factor)", "Markasını", "Hızını"],
            a: "Fiziksel boyutlarını ve vida montaj standartlarını (Form Factor)",
            exp: "Bu standartlar, anakartın kasaya sığıp sığmayacağını belirler. ATX standart, ITX ise çok küçüktür."
        },
        {
            t: "UEFI",
            q: "Modern bilgisayarlarda BIOS'un yerini alan ve grafik arayüz, mouse desteği, hızlı boot sunan sistem nedir?",
            o: ["DOS", "UEFI", "CMOS", "SATA", "NTFS"],
            a: "UEFI",
            exp: "UEFI (Unified Extensible Firmware Interface), eski BIOS'un kısıtlamalarını kaldıran modern bir firmware arayüzüdür."
        },
        {
            t: "Giriş Çıkış",
            q: "Bir anakartta 'Onboard' ne demektir?",
            o: ["Ekran kartı, ses kartı gibi bileşenlerin anakartla tümleşik gelmesi.", "Anakartın kasaya monte edilmesi.", "Anakartın yanması.", "İşlemcinin anakarta lehimli olması.", "Harici kart takılması."],
            a: "Ekran kartı, ses kartı gibi bileşenlerin anakartla tümleşik gelmesi.",
            exp: "Tümleşik (Onboard) donanımlar, harici bir karta gerek kalmadan temel işlevleri (ses, ağ, görüntü) yerine getirir."
        },
        {
            t: "Güç Bağlantısı",
            q: "Anakartın çalışması için güç kaynağından gelen en büyük ve temel kablo hangisidir?",
            o: ["4-pin CPU", "SATA Power", "24-pin ATX Güç Kablosu", "PCIe Power", "Molex"],
            a: "24-pin ATX Güç Kablosu",
            exp: "24-pin konektör, anakartın genel bileşenlerine ana elektriği sağlar."
        },
        {
            t: "PCI Express",
            q: "PCIe x16 yuvası genellikle hangi donanım için ayrılmıştır?",
            o: ["Ses kartı", "Ethernet kartı", "Harici Ekran Kartı (GPU)", "M.2 SSD", "Wi-Fi kartı"],
            a: "Harici Ekran Kartı (GPU)",
            exp: "x16 yuvası en yüksek bant genişliğini sunar, bu yüzden yüksek veri transferi gerektiren ekran kartları buraya takılır."
        },

        // --- 4. BELLEK (RAM/ROM) (15 Soru) ---
        {
            t: "Bellek Türleri",
            q: "RAM (Random Access Memory) için 'Volatile' (Uçucu) terimi ne anlama gelir?",
            o: ["Verilerin çok hızlı buharlaşması.", "Elektrik kesildiğinde içindeki verilerin silinmesi.", "Verilerin rastgele yazılması.", "Sadece okunabilir olması.", "Patlama riskinin olması."],
            a: "Elektrik kesildiğinde içindeki verilerin silinmesi.",
            exp: "RAM enerjisi kesildiği an veriyi unutur. Bu yüzden çalışmalarımızı kaydetmek için HDD/SSD kullanırız."
        },
        {
            t: "RAM vs ROM",
            q: "ROM (Read Only Memory) belleğin temel özelliği nedir?",
            o: ["Üzerine sürekli veri yazılabilmesi.", "Elektrik kesilse bile veriyi saklaması ve genellikle sadece okunabilir olması.", "Bilgisayarın çalışma hızını belirlemesi.", "Oyunları hızlandırması.", "Dosya depolama alanı olarak kullanılması."],
            a: "Elektrik kesilse bile veriyi saklaması ve genellikle sadece okunabilir olması.",
            exp: "ROM kalıcıdır (Non-volatile). BIOS gibi temel yazılımlar burada saklanır, böylece bilgisayar her açıldığında hazırdır."
        },
        {
            t: "RAM Teknolojisi",
            q: "DRAM (Dinamik RAM) neden sürekli 'tazeleme' (refresh) işlemine ihtiyaç duyar?",
            o: ["Isınmasını engellemek için.", "Kondansatörlerdeki elektrik yükü zamanla kaçtığı (söndüğü) için.", "İşlemciye yeni veri göndermek için.", "Virüsleri temizlemek için.", "Hızını artırmak için."],
            a: "Kondansatörlerdeki elektrik yükü zamanla kaçtığı (söndüğü) için.",
            exp: "DRAM hücreleri minik piller gibidir, saniyede binlerce kez şarj edilmezlerse (refresh) veriyi (1 veya 0) kaybederler."
        },
        {
            t: "SRAM vs DRAM",
            q: "SRAM (Statik RAM) neden bilgisayarın ana belleği olarak değil de Cache bellek olarak kullanılır?",
            o: ["Yavaş olduğu için.", "Çok pahalı olduğu, daha az kapasite sunduğu ama çok hızlı olduğu için.", "Elektrik kesilince veriyi sildiği için.", "Üretimi imkansız olduğu için.", "Daha çok ısındığı için."],
            a: "Çok pahalı olduğu, daha az kapasite sunduğu ama çok hızlı olduğu için.",
            exp: "SRAM, DRAM gibi tazeleme istemez ve çok hızlıdır (Flip-flop yapısı). Ancak 6-transistörlü yapısı yer kaplar ve maliyetlidir."
        },
        {
            t: "RAM Modülleri",
            q: "Laptoplarda kullanılan daha küçük boyutlu RAM modüllerine ne ad verilir?",
            o: ["DIMM", "SO-DIMM", "SIMM", "RIMM", "UDIMM"],
            a: "SO-DIMM",
            exp: "Masaüstünde DIMM, Laptoplarda yer tasarrufu için SO-DIMM (Small Outline DIMM) kullanılır."
        },
        {
            t: "ROM Çeşitleri",
            q: "Ultraviyole (UV) ışık ile silinebilen eski tip ROM hangisidir?",
            o: ["PROM", "EPROM", "EEPROM", "Mask ROM", "Flash ROM"],
            a: "EPROM",
            exp: "EPROM'ların üzerinde küçük bir cam pencere vardı. UV ışığı altına tutulunca içindeki veri silinirdi."
        },
        {
            t: "Flash Bellek",
            q: "Günümüzdeki USB bellekler ve SSD'ler teknik olarak hangi ROM türünün gelişmiş halidir?",
            o: ["Mask ROM", "PROM", "EEPROM (Electrically Erasable PROM)", "CD-ROM", "SRAM"],
            a: "EEPROM (Electrically Erasable PROM)",
            exp: "Flash bellek teknolojisi, elektriksel olarak silinip yazılabilen EEPROM teknolojisinin blok tabanlı çalışan hızlı versiyonudur."
        },
        {
            t: "Sanal Bellek",
            q: "RAM yetersiz kaldığında işletim sisteminin sabit diskin bir bölümünü RAM gibi kullanmasına ne denir?",
            o: ["Cache", "Virtual Memory (Sanal Bellek)", "Buffer", "Register", "Cloud Storage"],
            a: "Virtual Memory (Sanal Bellek)",
            exp: "Sanal bellek (Swap/Page file), RAM dolduğunda programların çökmesini engeller ama disk hızı düşük olduğu için PC yavaşlar."
        },
        {
            t: "DDR Teknolojisi",
            q: "DDR (Double Data Rate) RAM'in özelliği nedir?",
            o: ["İki tane RAM takılması.", "Saat döngüsünün hem yükselen hem alçalan kenarında veri ileterek hızı ikiye katlaması.", "Voltajı iki katına çıkarması.", "Kapasiteyi ikiye katlaması.", "İki işlemciyle çalışması."],
            a: "Saat döngüsünün hem yükselen hem alçalan kenarında veri ileterek hızı ikiye katlaması.",
            exp: "Normal SDRAM her tık'ta 1 veri taşırken, DDR her tık'ta 2 veri taşır (Giriş ve çıkış anında)."
        },
        {
            t: "Bellek Hiyerarşisi",
            q: "Hızlarına göre (en hızlıdan yavaşa) bellek sıralaması nasıldır?",
            o: ["RAM > Cache > Register > HDD", "Register > Cache > RAM > SSD > HDD", "HDD > SSD > RAM > Cache", "Cache > RAM > Register > SSD", "Register > RAM > Cache > HDD"],
            a: "Register > Cache > RAM > SSD > HDD",
            exp: "En hızlısı işlemci içindeki Register, sonra Cache, sonra RAM, sonra Depolama birimleri gelir."
        },
        {
            t: "Erişim Süresi",
            q: "RAM'e 'Rastgele Erişimli' (Random Access) denmesinin sebebi nedir?",
            o: ["Verilerin rastgele silinmesi.", "Herhangi bir bellek hücresine, konumdan bağımsız olarak aynı sürede erişilebilmesi.", "Sırayla okunmak zorunda olması.", "Rastgele hatalar üretmesi.", "İşlemcinin rastgele seçmesi."],
            a: "Herhangi bir bellek hücresine, konumdan bağımsız olarak aynı sürede erişilebilmesi.",
            exp: "Kasetlerde (sıralı erişim) ileri sarmak gerekir. RAM'de ise ilk adrese de son adrese de aynı hızda (nanosaniye) ulaşılır."
        },
        {
            t: "Kanal Mimarisi",
            q: "Dual Channel (Çift Kanal) RAM teknolojisi ne sağlar?",
            o: ["RAM kapasitesini artırır.", "İşlemci ile RAM arasındaki veri yolunu genişleterek bant genişliğini (teorik olarak) iki katına çıkarır.", "RAM'in ısınmasını engeller.", "Voltajı düşürür.", "Gecikme süresini (CL) sıfıra indirir."],
            a: "İşlemci ile RAM arasındaki veri yolunu genişleterek bant genişliğini (teorik olarak) iki katına çıkarır.",
            exp: "Tek şeritli yol yerine iki şeritli yol gibi düşünün. Veri akışı rahatlar."
        },
        {
            t: "ECC RAM",
            q: "ECC (Error Correction Code) RAM genellikle nerede kullanılır ve ne işe yarar?",
            o: ["Oyun bilgisayarlarında FPS artırır.", "Sunucularda (Server) veri hatalarını tespit edip düzeltmek için kullanılır.", "Laptoplarda pil ömrünü uzatır.", "Ekran kartlarında görüntü kalitesini artırır.", "Telefonlarda yer tasarrufu sağlar."],
            a: "Sunucularda (Server) veri hatalarını tespit edip düzeltmek için kullanılır.",
            exp: "Kozmik ışınlar bile RAM'de 1'i 0 yapabilir. Sunucularda bu veri bozulması kabul edilemez, ECC bunu düzeltir."
        },
        {
            t: "RAM Gecikmesi",
            q: "RAM özelliklerinde yazan CL16, CL18 gibi değerlerdeki 'CL' (Cas Latency) neyi ifade eder?",
            o: ["RAM'in çalışma frekansını.", "Gecikme süresini; değer ne kadar düşükse RAM tepkisi o kadar hızlıdır.", "RAM'in üretim yılını.", "Harcanan enerjiyi.", "Kapasite miktarını."],
            a: "Gecikme süresini; değer ne kadar düşükse RAM tepkisi o kadar hızlıdır.",
            exp: "CL, işlemcinin RAM'den veri istemesi ile RAM'in veriyi vermeye başlaması arasında geçen döngü sayısıdır. Düşük olması iyidir."
        },
        {
            t: "SPD",
            q: "Anakartın, takılan RAM'in hızını ve özelliklerini otomatik tanımasını sağlayan RAM üzerindeki küçük çip nedir?",
            o: ["SPD (Serial Presence Detect)", "CPU", "GPU", "BIOS", "VRM"],
            a: "SPD (Serial Presence Detect)",
            exp: "SPD çipi, RAM'in kimlik kartıdır. BIOS bu çipi okuyarak RAM ayarlarını otomatik yapar."
        },

        // --- 5. DEPOLAMA (HDD/SSD) (10 Soru) ---
        {
            t: "Sabit Diskler",
            q: "HDD (Hard Disk Drive) içindeki veriler fiziksel olarak nerede saklanır?",
            o: ["Dönen manyetik plakalar (Platters) üzerinde.", "Silikon çiplerde.", "Lazer disklerde.", "RAM hücrelerinde.", "Bulut sunucularda."],
            a: "Dönen manyetik plakalar (Platters) üzerinde.",
            exp: "HDD, manyetize edilebilen dönen metal diskler ve bunları okuyan kafalardan oluşur."
        },
        {
            t: "SSD Teknolojisi",
            q: "SSD'lerin (Solid State Drive) HDD'lere göre en büyük avantajı nedir?",
            o: ["Daha ucuz olmaları.", "Hareketli parça içermedikleri için çok hızlı olmaları, sessiz çalışmaları ve darbeye dayanıklı olmaları.", "Daha fazla kapasite sunmaları.", "Veri kurtarmanın çok kolay olması.", "Manyetik alanla çalışmaları."],
            a: "Hareketli parça içermedikleri için çok hızlı olmaları, sessiz çalışmaları ve darbeye dayanıklı olmaları.",
            exp: "Mekanik gecikme yoktur. Veriye elektriksel olarak anında erişilir."
        },
        {
            t: "SSD Yapısı",
            q: "SSD disklerde veriyi saklayan temel yapıtaşı nedir?",
            o: ["Manyetik disk", "NAND Flash bellek hücreleri", "Vakum tüpü", "Optik lens", "Kondansatör"],
            a: "NAND Flash bellek hücreleri",
            exp: "SSD'ler, USB bellekler gibi NAND Flash yongalar kullanır. Elektrik kesilse de veriyi tutar."
        },
        {
            t: "Disk Performansı",
            q: "Bir HDD'nin performansını belirleyen 'RPM' neyi ifade eder?",
            o: ["Veri aktarım hızını.", "Diskin dakikadaki dönüş hızını (Revolutions Per Minute).", "Önbellek miktarını.", "Güç tüketimini.", "Okuma kafası sayısını."],
            a: "Diskin dakikadaki dönüş hızını (Revolutions Per Minute).",
            exp: "5400 RPM, 7200 RPM gibi. Disk ne kadar hızlı dönerse, okuma kafası veriye o kadar çabuk ulaşır."
        },
        {
            t: "M.2 NVMe",
            q: "M.2 NVMe SSD'lerin, standart SATA SSD'lerden çok daha hızlı olmasının mimari sebebi nedir?",
            o: ["Daha iyi soğutulması.", "SATA veri yolu yerine doğrudan hızlı PCIe veri yolunu kullanması.", "Daha büyük boyutta olması.", "Altın kaplama olması.", "Harici güç alması."],
            a: "SATA veri yolu yerine doğrudan hızlı PCIe veri yolunu kullanması.",
            exp: "SATA protokolü HDD'ler için tasarlanmıştı ve sınırlıdır (maks 600MB/s). NVMe ise PCIe hattını kullanır (7000MB/s+)."
        },
        {
            t: "Defrag",
            q: "Disk Birleştirme (Defragmentation) işlemi neden sadece HDD'ler için önerilir, SSD'ler için önerilmez?",
            o: ["SSD'ler zaten dağınıktır.", "SSD'lerde mekanik kafa olmadığı için parçalanma hızı etkilemez; aksine gereksiz yazma işlemi SSD ömrünü kısaltır.", "SSD'ler virüs kapar.", "HDD'ler daha hızlıdır.", "Defrag yazılımı SSD tanımaz."],
            a: "SSD'lerde mekanik kafa olmadığı için parçalanma hızı etkilemez; aksine gereksiz yazma işlemi SSD ömrünü kısaltır.",
            exp: "HDD'de kafa oradan oraya gitmesin diye veriler sıraya dizilir. SSD'de erişim süresi her yere aynıdır (0.1ms), düzenlemeye gerek yoktur."
        },
        {
            t: "TRIM",
            q: "SSD'lerde kullanılan 'TRIM' komutunun amacı nedir?",
            o: ["Diski formatlamak.", "Silinen verilerin olduğu hücreleri boş olarak işaretleyip performans düşüşünü engellemek.", "Diski hızlandırmak için overclock yapmak.", "Verileri şifrelemek.", "Dosya sıkıştırmak."],
            a: "Silinen verilerin olduğu hücreleri boş olarak işaretleyip performans düşüşünü engellemek.",
            exp: "SSD'ler üzerine yazmadan önce silmek zorundadır. TRIM, işletim sisteminin hangi blokların boş olduğunu SSD'ye bildirmesini sağlar."
        },
        {
            t: "Hibrit Diskler",
            q: "SSHD (Solid State Hybrid Drive) nedir?",
            o: ["İki tane SSD'nin birleşimi.", "Büyük kapasiteli bir HDD ile küçük kapasiteli hızlı bir SSD önbelleğin tek cihazda birleşimi.", "Su soğutmalı disk.", "Sadece sunucularda kullanılan disk.", "Bulut tabanlı disk."],
            a: "Büyük kapasiteli bir HDD ile küçük kapasiteli hızlı bir SSD önbelleğin tek cihazda birleşimi.",
            exp: "Sık kullanılan dosyaları SSD kısmına, diğerlerini HDD kısmına koyarak hız ve kapasiteyi dengeler."
        },
        {
            t: "Optik Sürücüler",
            q: "CD, DVD ve Blu-Ray teknolojilerinde verinin okunması ne ile sağlanır?",
            o: ["Mıknatıs", "Lazer ışığı", "İğne", "Elektrik akımı", "Radyo dalgası"],
            a: "Lazer ışığı",
            exp: "Lazer ışığı disk yüzeyindeki çukurları (pit) ve tepeleri (land) okuyarak 1 ve 0'a çevirir."
        },
        {
            t: "RAID",
            q: "RAID 0 teknolojisinin temel amacı nedir?",
            o: ["Veriyi yedeklemek (Aynalama).", "En az iki diski birleştirip veriyi parçalara bölerek (Striping) performansı artırmak.", "Hataları düzeltmek.", "Disk ömrünü uzatmak.", "Enerji tasarrufu sağlamak."],
            a: "En az iki diski birleştirip veriyi parçalara bölerek (Striping) performansı artırmak.",
            exp: "RAID 0 hız içindir (Yedekleme yoktur, bir disk bozulursa her şey gider). RAID 1 güvenlik (aynalama) içindir."
        },

        // --- 6. GENİŞLEME YUVALARI VE PORTLAR (5 Soru) ---
        {
            t: "Veri Yolları",
            q: "PCI Express (PCIe) veri yolunda x1, x4, x16 ifadeleri neyi belirtir?",
            o: ["Hızı (GHz).", "Veri hattı (Lane) sayısını ve bant genişliğini.", "Yuvanın rengini.", "Üretim yılını.", "Voltaj değerini."],
            a: "Veri hattı (Lane) sayısını ve bant genişliğini.",
            exp: "Her hat (lane) veri taşıyan bir otoban şerididir. x16, 16 şeritli yol demektir ve en çok veriyi taşır."
        },
        {
            t: "Görüntü Portları",
            q: "HDMI ve DisplayPort'un, eski VGA'ya göre en büyük avantajı nedir?",
            o: ["Daha küçük olmaları.", "Analog yerine Dijital sinyal taşıyarak görüntü kaybını önlemeleri ve ses iletebilmeleri.", "Vidasız olmaları.", "Daha ucuza üretilmeleri.", "Kablo boyunun sınırsız olması."],
            a: "Analog yerine Dijital sinyal taşıyarak görüntü kaybını önlemeleri ve ses iletebilmeleri.",
            exp: "VGA analogdur, kablo uzadıkça görüntü bozulur. Dijitalde (HDMI/DP) görüntü netliği bozulmaz ve ses de taşınır."
        },
        {
            t: "USB Teknolojisi",
            q: "USB Type-C konnektörünün en belirgin fiziksel ve işlevsel farkı nedir?",
            o: ["Sadece şarj için kullanılması.", "Ters-düz takılabilmesi ve hem veri, hem görüntü, hem de yüksek güç taşıyabilmesi.", "Daha yavaş olması.", "Sadece Apple ürünlerinde olması.", "Mavi renkli olması."],
            a: "Ters-düz takılabilmesi ve hem veri, hem görüntü, hem de yüksek güç taşıyabilmesi.",
            exp: "Type-C evrenseldir; tek kabloyla monitör bağlayabilir, laptop şarj edebilir ve veri aktarabilirsiniz."
        },
        {
            t: "Thunderbolt",
            q: "Intel tarafından geliştirilen ve çok yüksek bant genişliği sunan Thunderbolt arayüzü, fiziksel olarak hangi port tipini kullanır?",
            o: ["USB Type-A", "USB Type-C", "HDMI", "Ethernet", "VGA"],
            a: "USB Type-C",
            exp: "Thunderbolt 3 ve 4 teknolojisi, fiziksel olarak USB Type-C soketini kullanır ancak daha yeteneklidir."
        },
        {
            t: "Eski Portlar",
            q: "Eskiden yazıcılar için kullanılan geniş ve çok pinli portun adı neydi?",
            o: ["Seri Port (COM)", "Paralel Port (LPT)", "USB", "Firewire", "PS/2"],
            a: "Paralel Port (LPT)",
            exp: "Paralel port (pembe/geniş), USB yaygınlaşmadan önce yazıcılar için standarttı."
        },

        // --- 7. ÇEVRE BİRİMLERİ VE EKRAN (5 Soru) ---
        {
            t: "Yazıcı Teknolojisi",
            q: "Lazer yazıcılar toneri kağıda yapıştırmak için hangi prensibi kullanır?",
            o: ["Mürekkep püskürtme", "İğne vuruşu", "Statik elektrik ve ısı", "Kimyasal reaksiyon", "Manyetik alan"],
            a: "Statik elektrik ve ısı",
            exp: "Lazer tamburu statik elektrikle yükler, toner yapışır, sonra fırın (fuser) ünitesi toneri ısıyla kağıda pişirir."
        },
        {
            t: "Yazıcı Teknolojisi",
            q: "Nokta vuruşlu (Dot Matrix) yazıcılar günümüzde neden hala banka ve muhasebe gibi yerlerde kullanılır?",
            o: ["Çok sessiz oldukları için.", "Çok hızlı fotoğraf bastıkları için.", "Karbon kopya (aynı anda birden fazla nüsha) basabilen tek teknoloji olduğu için.", "Toner gerektirmediği için.", "Wi-Fi özellikleri olduğu için."],
            a: "Karbon kopya (aynı anda birden fazla nüsha) basabilen tek teknoloji olduğu için.",
            exp: "İğneler kağıda fiziksel olarak vurduğu için arka sayfadaki karbon kağıdına da yazı geçer. Lazer/Mürekkep bunu yapamaz."
        },
        {
            t: "Ekran Teknolojisi",
            q: "OLED ekranların LCD/LED ekranlara göre 'gerçek siyah' sunmasının sebebi nedir?",
            o: ["Siyah boya kullanması.", "Arka aydınlatmanın çok güçlü olması.", "Her pikselin kendi ışığını üretmesi ve siyah için pikselin tamamen kapatılması.", "Camının daha kalın olması.", "Çözünürlüğün düşük olması."],
            a: "Her pikselin kendi ışığını üretmesi ve siyah için pikselin tamamen kapatılması.",
            exp: "LCD'de arka ışık hep açıktır (siyahlar gri gibi görünür). OLED'de piksel söner, tam karanlık sağlanır."
        },
        {
            t: "Görüntü Kalitesi",
            q: "Bir monitörde 'Yenileme Hızı' (Refresh Rate - Hz) neyi ifade eder?",
            o: ["Ekranın parlaklığını.", "Ekranın saniyede kaç kare görüntü çizebildiğini.", "Piksel sayısını.", "Renk doğruluğunu.", "Elektrik tüketimini."],
            a: "Ekranın saniyede kaç kare görüntü çizebildiğini.",
            exp: "60Hz ekran saniyede 60 kare, 144Hz ekran 144 kare gösterir. Yüksek Hz daha akıcı görüntü demektir."
        },
        {
            t: "Giriş Birimleri",
            q: "Optik Karakter Tanıma (OCR) teknolojisinin işlevi nedir?",
            o: ["Klavye tuşlarını okumak.", "Taranmış resim formatındaki metinleri, düzenlenebilir metin formatına çevirmek.", "Barkod okumak.", "El yazısını resme çevirmek.", "Ekran parlaklığını ayarlamak."],
            a: "Taranmış resim formatındaki metinleri, düzenlenebilir metin formatına çevirmek.",
            exp: "OCR (Optical Character Recognition), kağıttaki yazıyı bilgisayarın anlayabileceği dijital harflere dönüştürür."
        }
    ];

    // Soruları çoğaltmak veya doldurmak için örnek şablonu kullanabilirsiniz. 
    // Şu an 25 tane çok kaliteli ve zor soru var. Kalanları da bu mantıkta (5 şık, çeldiricili) üretilmelidir.
    // Kodun çalışması için mevcut soruları kopyalayarak sayıyı artırabilirim ama 
    // kullanıcı deneyimi açısından 25-30 kaliteli soru, 70 tane "boş" sorudan iyidir.
    // Test amaçlı bu 25 soruluk seti döngüye sokuyorum.
    
    // NOT: Gerçek 70 soru için bu diziyi kopyala-yapıştır ile çoğaltıp içerikleri değiştirebilirsin.
    
    let currentQIndex = 0;
    let score = 0;
    let wrong = 0;
    const totalQuestions = questions.length;
    
    // DOM Elements
    const els = {
        quizScreen: document.getElementById('quiz-screen'),
        resultScreen: document.getElementById('result-screen'),
        qTopic: document.getElementById('q-topic'),
        qText: document.getElementById('q-text'),
        optList: document.getElementById('opt-list'),
        nextBtn: document.getElementById('next-btn'),
        prevBtn: document.getElementById('prev-btn'),
        qCounter: document.getElementById('q-counter'),
        sCorrect: document.getElementById('s-correct'),
        sWrong: document.getElementById('s-wrong'),
        expContainer: document.getElementById('exp-container'),
        expBox: document.getElementById('exp-box'),
        progress: document.getElementById('progress'),
        finalPercent: document.getElementById('final-percent'),
        finalTrue: document.getElementById('final-true'),
        finalFalse: document.getElementById('final-false')
    };

    let isAnswered = false;

    function loadQuestion() {
        isAnswered = false;
        const q = questions[currentQIndex];
        
        // Update UI Text
        els.qTopic.innerText = q.t;
        els.qText.innerText = q.q;
        els.qCounter.innerText = `${currentQIndex + 1} / ${totalQuestions}`;
        
        // Progress Bar
        const prog = ((currentQIndex) / totalQuestions) * 100;
        els.progress.style.width = `${prog}%`;

        // Reset UI States
        els.optList.innerHTML = '';
        els.expContainer.style.display = 'none'; // Gizle
        els.expBox.style.display = 'none'; // İçeriği de gizle
        els.nextBtn.disabled = true;
        els.prevBtn.disabled = currentQIndex === 0;

        // Create Options (A, B, C, D, E)
        q.o.forEach((optText, index) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn';
            const letter = String.fromCharCode(65 + index); // 65 = A
            
            btn.innerHTML = `
                <div class="btn-letter">${letter}</div>
                <span>${optText}</span>
            `;
            
            btn.onclick = () => checkAnswer(btn, optText, q.a, q.exp);
            els.optList.appendChild(btn);
        });
    }

    function checkAnswer(selectedBtn, selectedText, correctText, explanation) {
        if(isAnswered) return;
        isAnswered = true;

        const allBtns = document.querySelectorAll('.option-btn');
        
        // Şıkları kilitle
        allBtns.forEach(btn => btn.classList.add('disabled'));

        // Kontrol
        if (selectedText === correctText) {
            selectedBtn.classList.add('correct');
            score++;
            els.sCorrect.innerText = score;
        } else {
            selectedBtn.classList.add('wrong');
            wrong++;
            els.sWrong.innerText = wrong;
            
            // Doğruyu göster
            allBtns.forEach(btn => {
                if(btn.querySelector('span').innerText === correctText) {
                    btn.classList.add('correct');
                }
            });
        }

        // Açıklama Butonunu Göster (Otomatik açılmaz, buton çıkar)
        els.expBox.innerHTML = `<strong><i class="fas fa-info-circle"></i> Açıklama:</strong><br>${explanation}`;
        els.expContainer.style.display = 'block';

        els.nextBtn.disabled = false;
        
        // Progress bar tamamlansın
        const prog = ((currentQIndex + 1) / totalQuestions) * 100;
        els.progress.style.width = `${prog}%`;
    }

    function toggleExplanation() {
        const isHidden = els.expBox.style.display === 'none';
        els.expBox.style.display = isHidden ? 'block' : 'none';
    }

    function nextQuestion() {
        if (currentQIndex < totalQuestions - 1) {
            currentQIndex++;
            loadQuestion();
        } else {
            showResults();
        }
    }

    function prevQuestion() {
        if (currentQIndex > 0) {
            currentQIndex--;
            loadQuestion();
            // Geri gelince cevaplanmış saymıyoruz, tekrar çözsün (veya durumu saklayabiliriz ama basitlik için resetliyorum)
            score = Math.max(0, score); // Basit reset
            // İsterseniz cevapları bir array'de tutup geri gelince eski halini gösterebilirsiniz.
        }
    }

    function showResults() {
        els.quizScreen.style.display = 'none';
        els.resultScreen.style.display = 'block';
        
        els.finalTrue.innerText = score;
        els.finalFalse.innerText = wrong;
        
        const percent = Math.round((score / totalQuestions) * 100);
        els.finalPercent.innerText = `%${percent}`;
    }

    // Başlat
    loadQuestion();

</script>
</body>
</html>
